# 继承

Java 只支持单继承，不支持多继承，但支持多层继承

```java
public class Daddy {}
public class son extends Daddy {}
```

继承后，子类可以使用父类中非私有成员

继承中变量访问采用就近原则，首先在子类局部找，然后在子类成员找，最后在父类成员找。即在上述三个范围中变量可以重名

super: 父类对象引用

this: 子类对象引用

```java
class Animal {
    private String name;
    public Animal (String name) {
        this.name = name;
    }
}
class Dog extends Animal {
    public Dog (String name){
        super(name);    // 调用父类构造函数
    }
}
```

子类中所有构造方法默认都会访问父类中无参的构造方法，故建议在父类中给出无参构造方法

在对象的堆内存中，会单独存在一块 super 区域用于存放父类数据

## 方法重写

子类中出现和父类一样的方法声明，包括方法名和参数列表，需要通过 Override 注解（不能重写私有方法，被重写的方法权限不能比原方法权限更低）

```java
class Daddy {
    public void say (int i) {
        System.out.println("I am Daddy");
    }
}

class son extends Daddy {
    @Override
    public void say (int i) {
        System.out.println("I am son");
    }
}
```

# 修饰符

## package

包就是文件夹，用于管理文件

## import

导入包

## 权限修饰符

public：都可以访问
protected：包内可以访问，包外子类可以访问
默认：包内可以访问
private：类内可以访问

## final

用于修饰成员方法、成员变量、类

被 `final` 修饰的类不能被继承，方法不能被重写，变量为常量不能再次赋值

`final` 修饰基本数据类型变量代表其值不能发生改变，修饰引用数据变量代表其地址值不能发生改变，内容可变

```java
public static void main (String[] args) {
    final Student s = new Student();
    s = new Student(); // 错误
    s.setAge(25);   // 正确
}
```

## static

可用于修饰成员方法及变量

被 `static` 修饰的东西被类的所有对象共享，可以直接通过类名调用，也可通过对象名调用（推荐使用类名调用）

```java
class S {
    public static a = 1;
}

public static void main (String[] args) {
    int b = S.a;
}
```

**静态成员方法只能访问静态成员**

# 多态

同一个对象，在不同时刻表现出不同的形态

前提：有继承或实现关系、方法的重写、父类引用指向子类对象

**多态成员访问特点**：

- 成员变量：编译看父类，运行看父类（重名时优先使用父类变量）
- 成员方法：编译看父类，运行看子类（重名时优先使用子类方法）

```java
class Animal {
    public int age = 40;
    public void eat () {System.out.println("food")}
}

class Cat extends Animal {
    public int age = 20;

    @Override
    public void eat () {System.tou.println("fish")}
}

public class AnimalDemo {
    public static void main () {
        Animal a = new Cat();

        System.out.println(a.age);  // 40
        a.eat();                    // fish
    }
}
```

向上转型：父类指针指向子类对象

- 不能调用子类特有的方法

向下转型：将父类对象强制转换为子类对象（前提：父类对象指向的是子类对象）

- 转型之后就可以调用子类的方法
- ```java
    public void eat(Animal a){
        if(a instanceof Dog){   // instanceof: 检查对象是否为特定类或其子类
            Dog d = (Dog)a;
            d.eat();
            d.run();//狗有一个跑的方法
        }
        if(a instanceof Cat){
            Cat c = (Cat)a;
            c.eat();
            System.out.println("我也想跑，但是不会"); //猫会抱怨
        }
        a.eat();//其他动物只会吃
    }
    eat(new Cat());
    eat(new Cat());
    eat(new Dog());
  ```

# 抽象类

没有方法体的方法应定义为抽象类，类中有抽象方法则类必须定义为抽象类

抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类，使用`abstract`修饰

抽象类不能实例化，只能参照多态的方式通过子类实例化，即抽象类多态

抽象类的子类要么重写抽象类中的所有抽象方法，要么是抽象类

```java
abstract class Animal {
    private String name;
    private int age;

    public Animal (String name, int age) {
        this.name = name;
        this.age = age;
    }

    public abstract void eat();
}

class Cat extends Animal {
    public Cat (String name, int age) {
        super(name, age);
    }

    @Override
    public void eat () {
        System.out.println("fish");
    }
}
```

# 接口
